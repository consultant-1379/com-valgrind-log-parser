package se.ericsson.cba.com.valgrindlogparser;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.File;

import java.util.ArrayList;
import java.util.HashMap;
import java.io.IOException;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * ValgrindLogParser parses all the valid valgrind xml logs generated by valgrind (memcheck) tool
 * and writes the parsed information into temporary files. These temporary files which will be used
 * in preparing unique leak/error stack trace information.
 *
 * @author  XROHVIJ (Rohit Vijaywargi)
 * @version 1.0.0
 * @since   2015-02-15
 */
public class ValgrindLogParser extends DefaultHandler {

	private static final String FILE_SEPARATOR = System.getProperty("file.separator");

	private BufferedWriter writerObj1, writerObj2;
	private StringBuilder sb;
	private boolean errorTrace, kind, leakedbytes, auxwhat, stack, frame, func, file, line, obj;
	private int leakedbytesValue, funcValue, fileValue, lineValue, objValue;
	private String objectString;

	/**
	 * Default Constructor
	 */
	public ValgrindLogParser() {
	}

	/**
	 * Parametrized Constructor
	 */
	public ValgrindLogParser(BufferedWriter writerObj1, BufferedWriter writerObj2) {
		this.writerObj1 = writerObj1;
		this.writerObj2 = writerObj2;
		sb = new StringBuilder("");
		objectString = new String("");

		errorTrace = false;
		kind = false;
		leakedbytes = false;
		auxwhat = false;
		stack = false;
		frame = false;
		func = false;
		file = false;
		line = false;
		obj = false;

		leakedbytesValue = 0;
		objValue = 0;
		funcValue = 0;
		fileValue = 0;
		lineValue = 0;
	}

	/**
	 * Parse Valgrind XML Logs using SAX Parser
	 * @param inputDirectory Directory where the valgrind logs are available
	 * @param outputDirectory Directory where the parsed files(temporary files) will be created
	 * @param fileNames ArrayList containing valgrind log file names
	 * @return invalidValgrindXMLLogsMap Map containing invalid XML file name as key and exception message as value
	 * @throws ParserConfigurationException, IllegalArgumentException, SAXException, IOException
	 */
	public HashMap<String, String> parseValgrindXMLLogs(String inputDirectory, String outputDirectory, ArrayList<String> fileNames) throws ParserConfigurationException, IllegalArgumentException, SAXException, IOException {

		SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
		SAXParser parser = saxParserFactory.newSAXParser();
		ValgrindLogParser logParser;
		File file;
		BufferedWriter writerObj1, writerObj2;

		HashMap<String, String> invalidValgrindXMLLogsMap = new HashMap<String, String>();

		file = new File(outputDirectory + FILE_SEPARATOR + "Log_ParsedFiles");
		file.mkdir();
		file = new File(outputDirectory + FILE_SEPARATOR + "Log_LeakedBytes");
		file.mkdir();

		for(String fileName : fileNames) {
			file = new File(inputDirectory + FILE_SEPARATOR + fileName);
			writerObj1 = new BufferedWriter(new FileWriter(outputDirectory + FILE_SEPARATOR + "Log_ParsedFiles" + FILE_SEPARATOR + fileName));
			writerObj2 = new BufferedWriter(new FileWriter(outputDirectory + FILE_SEPARATOR + "Log_LeakedBytes" + FILE_SEPARATOR + fileName));
			logParser = new ValgrindLogParser(writerObj1, writerObj2);
			try {
				parser.parse(file, logParser);
			} catch (SAXException sxe) {
				invalidValgrindXMLLogsMap.put(fileName, sxe.toString());
			} finally {
				writerObj1.close();
				writerObj2.close();
			}
		}
		return invalidValgrindXMLLogsMap;
	}

	public void startDocument() throws SAXException {
	}

	public void endDocument() throws SAXException {
	}

	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
		if(qName.equals("error")) {
			errorTrace = true;
			return;
		}

		if(errorTrace) {
			if(qName.equals("kind")) {
				sb = new StringBuilder("");
				kind = true;
				return;
			}
			if(qName.equals("leakedbytes")) {
				sb = new StringBuilder("");
				leakedbytes = true;
				return;
			}
			if(qName.equals("auxwhat") && (stack == false)) {
				sb = new StringBuilder("");
				auxwhat = true;
				return;
			}
			if(qName.equals("stack")) {
				stack = true;
				return;
			}
			if(stack) {
				if(qName.equals("frame")) {
					frame = true;
					return;
				}
				if(frame) {
					if(qName.equals("obj") && obj == false) {
						sb = new StringBuilder("");
						obj = true;
						objValue = 1;
						return;
					}
					if(qName.equals("fn") && func == false) {
						sb = new StringBuilder("");
						func = true;
						funcValue = 1;
						return;
					}
					if(qName.equals("file") && file == false) {
						sb = new StringBuilder("");
						file = true;
						fileValue = 1;
						return;
					}
					if(qName.equals("line") && line == false) {
						sb = new StringBuilder("");
						line = true;
						lineValue = 1;
						return;
					}
				}
			}
		}
	}

	public void endElement(String uri, String localName, String qName) throws SAXException {
		try{
			if(qName.equals("error")) {
				writerObj1.write("====");
				writerObj1.newLine();
				if(leakedbytesValue == 0) {
					writerObj2.write("0");
					writerObj2.newLine();
				} else {
					leakedbytesValue = 0;
				}
				errorTrace = false;
				return;
			}

			if(errorTrace) {
				if(qName.equals("kind")) {
					writerObj1.write("==== " + sb);
					writerObj1.newLine();
					kind = false;
					return;
				}
				if(qName.equals("leakedbytes")) {
					writerObj2.write("" + sb);
					writerObj2.newLine();
					leakedbytesValue = 1;
					leakedbytes = false;
					return;
				}
				if(qName.equals("auxwhat") && (stack == false)) {
					String auxiliaryInfo = new String(sb);
					if(auxiliaryInfo.startsWith("Address 0x") || auxiliaryInfo.startsWith("Address 0X")) {
						writerObj1.write("==== *********************** Auxiliary Information ***********************");
					} else {
						writerObj1.write("==== " + auxiliaryInfo);
					}
					writerObj1.newLine();
					auxwhat = false;
					return;
				}
				if(qName.equals("stack")) {
					stack = false;
					return;
				}
				if(stack) {
					if(qName.equals("frame")) {
						if(funcValue == 0 && fileValue == 0 && lineValue == 0 && objValue == 0) {
							writerObj1.write("==== ???");
							writerObj1.newLine();
						} else if(funcValue == 0 && fileValue == 0 && lineValue == 0 && objValue == 1) {
							writerObj1.write("==== ??? (in " + objectString + ")");
							writerObj1.newLine();
							objValue = 0;
						} else if(funcValue == 1 && fileValue == 0 && lineValue == 0 && objValue == 0) {
							writerObj1.write(" (in ???)");
							writerObj1.newLine();
							funcValue = 0;
						} else if(funcValue == 1 && fileValue == 0 && lineValue == 0 && objValue == 1) {
							writerObj1.write(" (in " + objectString + ")");
							writerObj1.newLine();
							funcValue = 0;
							objValue = 0;
						} else {
							writerObj1.newLine();
							funcValue = 0;
							fileValue = 0;
							lineValue = 0;
							objValue = 0;
						}
						objectString = "";
						frame = false;
						return;
					}
					if(frame) {
						if(qName.equals("obj")) {
							objectString = new String(sb);
							obj = false;
							return;
						}
						if(qName.equals("fn")) {
							writerObj1.write("==== " + sb);
							func = false;
							return;
						}
						if(qName.equals("file")) {
							writerObj1.write(" (" + sb);
							file = false;
							return;
						}
						if(qName.equals("line")) {
							writerObj1.write(":" + sb + ")");
							line = false;
							return;
						}
					}
				}
			}
		} catch (IOException ex) {
			System.out.println("Caught IOException");
		}
	}

	public void characters(char ch[], int start, int length) throws SAXException {
		if(errorTrace) {
			if(kind) {
				sb.append(ch, start, length);
				return;
			}
			if(leakedbytes) {
				sb.append(ch, start, length);
				return;
			}
			if((auxwhat == true) && (stack == false)) {
				sb.append(ch, start, length);
				return;
			}
			if(stack) {
				if(frame) {
					if(obj) {
						sb.append(ch, start, length);
						return;
					}
					if(func) {
						sb.append(ch, start, length);
						return;
					}
					if(file) {
						sb.append(ch, start, length);
						return;
					}
					if(line) {
						sb.append(ch, start, length);
						return;
					}
				}
			}
		}
	}
}
