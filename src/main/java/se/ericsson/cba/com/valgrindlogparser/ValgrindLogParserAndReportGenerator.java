package se.ericsson.cba.com.valgrindlogparser;

import java.io.File;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.FileNotFoundException;

import java.util.Date;
import java.util.ArrayList;
import java.util.HashMap;

import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;

/**
 * ValgrindLogParserAndReportGenerator takes all the valgrind xml logs generated by
 * valgrind (memcheck) tool as input and prepares a valgrind report in html format.
 *
 * @author  XROHVIJ (Rohit Vijaywargi)
 * @version 1.0.0
 * @since   2015-02-15
 */
public class ValgrindLogParserAndReportGenerator {

	private static final String FILE_SEPARATOR = System.getProperty("file.separator");

	private String inputDirectory;
	private String outputDirectory;

	private ArrayList<String> fileNames;
	private ArrayList<String> uniqueLeakErrorStackTraceList;
	private ArrayList<ArrayList<Long>> leakedBytesList;
	private ArrayList<ArrayList<String>> filesContainingUniqueLeakErrorStackTraceList;
	private ArrayList<Integer> frequencyCountOfUniqueLeakErrorStackTraceList;

	/**
	 * Constructor
	 */
	public ValgrindLogParserAndReportGenerator() {
		fileNames = new ArrayList<String>();
		uniqueLeakErrorStackTraceList = new ArrayList<String>();
		leakedBytesList = new ArrayList<ArrayList<Long>>();
		filesContainingUniqueLeakErrorStackTraceList = new ArrayList<ArrayList<String>>();
		frequencyCountOfUniqueLeakErrorStackTraceList = new ArrayList<Integer>();
	}

	/**
	 * Collects all the valgrind log filenames in a list
	 * @throws FileNotFoundException, IOException
	 */
	private void getLogFiles() throws FileNotFoundException, IOException {

		File startingDirectory = new File(inputDirectory);
		File[] files = startingDirectory.listFiles();

		for (File file : files) {
			if (!(file.isDirectory())) {
				String fileName = file.getName();
				if(fileName.startsWith("valgrind_") && (fileName.endsWith(".log") || fileName.endsWith(".xml"))) {
					fileNames.add(fileName);
				}
			}
		}
		System.out.println("\nTotal Valgrind Logs = " + fileNames.size()+"\n");
	}

	/**
	 * Prepares unique leak/error trace information
	 * @param vlesti ValgrindLeakErrorStackTraceInformation instance
	 * @throws IOException
	 */
	private void prepareUniqueLeakErrorTraceInfo(ValgrindLeakErrorStackTraceInformation vlesti) throws IOException {

		BufferedReader readerObj1, readerObj2;
		String strLine, stackTrace;
		StringBuilder sb = new StringBuilder("");
		int uniqueLeakErrorTraceCounter = 0;

		for(String fileName : fileNames) {

			readerObj1 = new BufferedReader(new InputStreamReader(new FileInputStream(outputDirectory + FILE_SEPARATOR + "Log_ParsedFiles" + FILE_SEPARATOR + fileName)));
			readerObj2 = new BufferedReader(new InputStreamReader(new FileInputStream(outputDirectory + FILE_SEPARATOR + "Log_LeakedBytes" + FILE_SEPARATOR + fileName)));

			while((strLine = readerObj1.readLine()) != null) {
				String[] str = strLine.split(" ");

				// Line containing only "====" marks end of 1 leak/error stack trace
				if(str.length == 1) {
					stackTrace = new String(sb);
					incrementLeakErrorTypeCountWithRepeatedOccurrence(vlesti, stackTrace);

					// Place the very first leak/error stack trace, directly into the list
					if(uniqueLeakErrorStackTraceList.size() == 0) {
						uniqueLeakErrorStackTraceList.add(stackTrace);

						leakedBytesList.add(new ArrayList<Long>());
						long bytesLeaked = Long.parseLong(readerObj2.readLine());
						if(stackTrace.contains("Leak_DefinitelyLost") || stackTrace.contains("Leak_IndirectlyLost") || stackTrace.contains("Leak_PossiblyLost") || stackTrace.contains("Leak_StillReachable")) {
							leakedBytesList.get(uniqueLeakErrorTraceCounter).add(bytesLeaked);
							leakedBytesList.get(uniqueLeakErrorTraceCounter).add(bytesLeaked);
						} else {
							leakedBytesList.get(uniqueLeakErrorTraceCounter).add(bytesLeaked);
						}

						filesContainingUniqueLeakErrorStackTraceList.add(new ArrayList<String>());
						filesContainingUniqueLeakErrorStackTraceList.get(uniqueLeakErrorTraceCounter).add(fileName);

						frequencyCountOfUniqueLeakErrorStackTraceList.add(1);
						uniqueLeakErrorTraceCounter++;
					} else {

						// For any other leak/error stack trace, before placing it in the list, verify whether it already exists in the list
						if(uniqueLeakErrorStackTraceList.contains(stackTrace)) {
							int matchingIndex = uniqueLeakErrorStackTraceList.indexOf(stackTrace);

							long bytesLeaked = Long.parseLong(readerObj2.readLine());
							if(stackTrace.contains("Leak_DefinitelyLost") || stackTrace.contains("Leak_IndirectlyLost") || stackTrace.contains("Leak_PossiblyLost") || stackTrace.contains("Leak_StillReachable")) {
								long max = leakedBytesList.get(matchingIndex).get(0);
								long sum = leakedBytesList.get(matchingIndex).get(1) + bytesLeaked;

								if(max < bytesLeaked) {
									leakedBytesList.get(matchingIndex).set(0, bytesLeaked);
								}
								leakedBytesList.get(matchingIndex).set(1, sum);
							}

							// To use memory efficiently, ensure that only 5 file names will be collected which contains leak/error stack trace
							if(filesContainingUniqueLeakErrorStackTraceList.get(matchingIndex).size() < 5) {
								if(!(filesContainingUniqueLeakErrorStackTraceList.get(matchingIndex).contains(fileName))) {
									filesContainingUniqueLeakErrorStackTraceList.get(matchingIndex).add(fileName);
								}
							}

							int freqCount = frequencyCountOfUniqueLeakErrorStackTraceList.get(matchingIndex);
							frequencyCountOfUniqueLeakErrorStackTraceList.set(matchingIndex, (freqCount + 1));

						} else {
							uniqueLeakErrorStackTraceList.add(stackTrace);

							leakedBytesList.add(new ArrayList<Long>());
							long bytesLeaked = Integer.parseInt(readerObj2.readLine());
							if(stackTrace.contains("Leak_DefinitelyLost") || stackTrace.contains("Leak_IndirectlyLost") || stackTrace.contains("Leak_PossiblyLost") || stackTrace.contains("Leak_StillReachable")) {
								leakedBytesList.get(uniqueLeakErrorTraceCounter).add(bytesLeaked);
								leakedBytesList.get(uniqueLeakErrorTraceCounter).add(bytesLeaked);
							} else {
								leakedBytesList.get(uniqueLeakErrorTraceCounter).add(bytesLeaked);
							}

							filesContainingUniqueLeakErrorStackTraceList.add(new ArrayList<String>());
							filesContainingUniqueLeakErrorStackTraceList.get(uniqueLeakErrorTraceCounter).add(fileName);

							frequencyCountOfUniqueLeakErrorStackTraceList.add(1);
							uniqueLeakErrorTraceCounter++;
						}
					}
					sb = new StringBuilder("");
				} else if(str.length > 1) {
					sb.append(strLine + "%");
				} else {
				}
			}
			readerObj1.close();
			readerObj2.close();
		}

		System.out.println("Unique leak/error stack traces count = " + uniqueLeakErrorStackTraceList.size());

		deleteFile(new File(outputDirectory +  FILE_SEPARATOR + "Log_ParsedFiles"));
		deleteFile(new File(outputDirectory +  FILE_SEPARATOR + "Log_LeakedBytes"));
	}

	/**
	 * Increment the leak/error type count
	 * @param vlesti ValgrindLeakErrorStackTraceInformation instance
	 * @param stackTrace stack trace belonging to particular leak/error type
	 */
	private void incrementLeakErrorTypeCountWithRepeatedOccurrence(ValgrindLeakErrorStackTraceInformation vlesti, String stackTrace) {
		if(stackTrace.contains("Leak_DefinitelyLost")) {
			vlesti.setDefinitelyLostCount(vlesti.getDefinitelyLostCount() + 1);
		} else if(stackTrace.contains("Leak_IndirectlyLost")) {
			vlesti.setIndirectlyLostCount(vlesti.getIndirectlyLostCount() + 1);
		} else if(stackTrace.contains("Leak_PossiblyLost")) {
			vlesti.setPossiblyLostCount(vlesti.getPossiblyLostCount() + 1);
		} else if(stackTrace.contains("Leak_StillReachable")) {
			vlesti.setStillReachableCount(vlesti.getStillReachableCount() + 1);
		} else if(stackTrace.contains("UninitValue")) {
			vlesti.setUninitValueCount(vlesti.getUninitValueCount() + 1);
		} else if(stackTrace.contains("UninitCondition")) {
			vlesti.setUninitCondCount(vlesti.getUninitCondCount() + 1);
		} else if(stackTrace.contains("InvalidWrite")) {
			vlesti.setInvalidWriteCount(vlesti.getInvalidWriteCount() + 1);
		} else if(stackTrace.contains("InvalidRead")) {
			vlesti.setInvalidReadCount(vlesti.getInvalidReadCount() + 1);
		} else if(stackTrace.contains("InvalidJump")) {
			vlesti.setInvalidJumpCount(vlesti.getInvalidJumpCount() + 1);
		} else if(stackTrace.contains("InvalidMemPool")) {
			vlesti.setInvalidMemPoolCount(vlesti.getInvalidMemPoolCount() + 1);
		} else if(stackTrace.contains("ClientCheck")) {
			vlesti.setClientCheckCount(vlesti.getClientCheckCount() + 1);
		} else if(stackTrace.contains("SyscallParam")) {
			vlesti.setSyscallParamCount(vlesti.getSyscallParamCount() + 1);
		} else if(stackTrace.contains("InvalidFree")) {
			vlesti.setInvalidFreeCount(vlesti.getInvalidFreeCount() + 1);
		} else if(stackTrace.contains("MismatchedFree")) {
			vlesti.setMismatchedFreeCount(vlesti.getMismatchedFreeCount() + 1);
		} else if(stackTrace.contains("Overlap")) {
			vlesti.setOverlapCount(vlesti.getOverlapCount() + 1);
		} else {
			vlesti.setOtherLeakErrorCount(vlesti.getOtherLeakErrorCount() + 1);
		}
		vlesti.setTotalLeakErrorCount(vlesti.getTotalLeakErrorCount() + 1);
	}

	/**
	 * Segregates each leak/error stack trace information based on their type
	 * @param vlesti ValgrindLeakErrorStackTraceInformation instance
	 */
	private void prepareValgrindReport(ValgrindLeakErrorStackTraceInformation vlesti) {

		int pos = 0;

		while(uniqueLeakErrorStackTraceList.size() > 0) {

			pos = uniqueLeakErrorStackTraceList.size() - 1;

			if(uniqueLeakErrorStackTraceList.get(pos).contains("Leak_DefinitelyLost")) {
				vlesti.getDefinitelyLostLeakInformationList().add(new ArrayList<String>());
				vlesti.getDefinitelyLostLeakInformationList().get(vlesti.getUniqueDefinitelyLostCount()).add(getUniqueStackTrace("Leak_DefinitelyLost", pos));
				vlesti.getDefinitelyLostLeakInformationList().get(vlesti.getUniqueDefinitelyLostCount()).add(getStackTraceFrequency(pos) + "");
				vlesti.getFileNamesListForDefinitelyLostLeakType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueDefinitelyLostCount(vlesti.getUniqueDefinitelyLostCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("Leak_IndirectlyLost")) {
				vlesti.getIndirectlyLostLeakInformationList().add(new ArrayList<String>());
				vlesti.getIndirectlyLostLeakInformationList().get(vlesti.getUniqueIndirectlyLostCount()).add(getUniqueStackTrace("Leak_IndirectlyLost", pos));
				vlesti.getIndirectlyLostLeakInformationList().get(vlesti.getUniqueIndirectlyLostCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForIndirectlyLostLeakType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueIndirectlyLostCount(vlesti.getUniqueIndirectlyLostCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("Leak_PossiblyLost")) {
				vlesti.getPossiblyLostLeakInformationList().add(new ArrayList<String>());
				vlesti.getPossiblyLostLeakInformationList().get(vlesti.getUniquePossiblyLostCount()).add(getUniqueStackTrace("Leak_PossiblyLost", pos));
				vlesti.getPossiblyLostLeakInformationList().get(vlesti.getUniquePossiblyLostCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForPossiblyLostLeakType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniquePossiblyLostCount(vlesti.getUniquePossiblyLostCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("Leak_StillReachable")) {
				vlesti.getStillReachableLeakInformationList().add(new ArrayList<String>());
				vlesti.getStillReachableLeakInformationList().get(vlesti.getUniqueStillReachableCount()).add(getUniqueStackTrace("Leak_StillReachable", pos));
				vlesti.getStillReachableLeakInformationList().get(vlesti.getUniqueStillReachableCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForStillReachableLeakType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueStillReachableCount(vlesti.getUniqueStillReachableCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("UninitValue")) {
				vlesti.getUninitValueErrorInformationList().add(new ArrayList<String>());
				vlesti.getUninitValueErrorInformationList().get(vlesti.getUniqueUninitValueCount()).add(getUniqueStackTrace("UninitValue", pos));
				vlesti.getUninitValueErrorInformationList().get(vlesti.getUniqueUninitValueCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForUninitValueErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueUninitValueCount(vlesti.getUniqueUninitValueCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("UninitCondition")) {
				vlesti.getUninitCondErrorInformationList().add(new ArrayList<String>());
				vlesti.getUninitCondErrorInformationList().get(vlesti.getUniqueUninitCondCount()).add(getUniqueStackTrace("UninitCondition", pos));
				vlesti.getUninitCondErrorInformationList().get(vlesti.getUniqueUninitCondCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForUninitCondErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueUninitCondCount(vlesti.getUniqueUninitCondCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("InvalidWrite")) {
				vlesti.getInvalidWriteErrorInformationList().add(new ArrayList<String>());
				vlesti.getInvalidWriteErrorInformationList().get(vlesti.getUniqueInvalidWriteCount()).add(getUniqueStackTrace("InvalidWrite", pos));
				vlesti.getInvalidWriteErrorInformationList().get(vlesti.getUniqueInvalidWriteCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForInvalidWriteErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueInvalidWriteCount(vlesti.getUniqueInvalidWriteCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("InvalidRead")) {
				vlesti.getInvalidReadErrorInformationList().add(new ArrayList<String>());
				vlesti.getInvalidReadErrorInformationList().get(vlesti.getUniqueInvalidReadCount()).add(getUniqueStackTrace("InvalidRead", pos));
				vlesti.getInvalidReadErrorInformationList().get(vlesti.getUniqueInvalidReadCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForInvalidReadErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueInvalidReadCount(vlesti.getUniqueInvalidReadCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("InvalidJump")) {
				vlesti.getInvalidJumpErrorInformationList().add(new ArrayList<String>());
				vlesti.getInvalidJumpErrorInformationList().get(vlesti.getUniqueInvalidJumpCount()).add(getUniqueStackTrace("InvalidJump", pos));
				vlesti.getInvalidJumpErrorInformationList().get(vlesti.getUniqueInvalidJumpCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForInvalidJumpErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueInvalidJumpCount(vlesti.getUniqueInvalidJumpCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("InvalidMemPool")) {
				vlesti.getInvalidMemPoolErrorInformationList().add(new ArrayList<String>());
				vlesti.getInvalidMemPoolErrorInformationList().get(vlesti.getUniqueInvalidMemPoolCount()).add(getUniqueStackTrace("InvalidMemPool", pos));
				vlesti.getInvalidMemPoolErrorInformationList().get(vlesti.getUniqueInvalidMemPoolCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForInvalidMemPoolErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueInvalidMemPoolCount(vlesti.getUniqueInvalidMemPoolCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("ClientCheck")) {
				vlesti.getClientCheckErrorInformationList().add(new ArrayList<String>());
				vlesti.getClientCheckErrorInformationList().get(vlesti.getUniqueClientCheckCount()).add(getUniqueStackTrace("ClientCheck", pos));
				vlesti.getClientCheckErrorInformationList().get(vlesti.getUniqueClientCheckCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForClientCheckErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueClientCheckCount(vlesti.getUniqueClientCheckCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("SyscallParam")) {
				vlesti.getSyscallParamErrorInformationList().add(new ArrayList<String>());
				vlesti.getSyscallParamErrorInformationList().get(vlesti.getUniqueSyscallParamCount()).add(getUniqueStackTrace("SyscallParam", pos));
				vlesti.getSyscallParamErrorInformationList().get(vlesti.getUniqueSyscallParamCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForSyscallParamErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueSyscallParamCount(vlesti.getUniqueSyscallParamCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("InvalidFree")) {
				vlesti.getInvalidFreeErrorInformationList().add(new ArrayList<String>());
				vlesti.getInvalidFreeErrorInformationList().get(vlesti.getUniqueInvalidFreeCount()).add(getUniqueStackTrace("InvalidFree", pos));
				vlesti.getInvalidFreeErrorInformationList().get(vlesti.getUniqueInvalidFreeCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForInvalidFreeErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueInvalidFreeCount(vlesti.getUniqueInvalidFreeCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("MismatchedFree")) {
				vlesti.getMismatchedFreeErrorInformationList().add(new ArrayList<String>());
				vlesti.getMismatchedFreeErrorInformationList().get(vlesti.getUniqueMismatchedFreeCount()).add(getUniqueStackTrace("MismatchedFree", pos));
				vlesti.getMismatchedFreeErrorInformationList().get(vlesti.getUniqueMismatchedFreeCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForMismatchedFreeErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueMismatchedFreeCount(vlesti.getUniqueMismatchedFreeCount() + 1);
			} else if(uniqueLeakErrorStackTraceList.get(pos).contains("Overlap")) {
				vlesti.getOverlapErrorInformationList().add(new ArrayList<String>());
				vlesti.getOverlapErrorInformationList().get(vlesti.getUniqueOverlapCount()).add(getUniqueStackTrace("Overlap", pos));
				vlesti.getOverlapErrorInformationList().get(vlesti.getUniqueOverlapCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForOverlapErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueOverlapCount(vlesti.getUniqueOverlapCount() + 1);
			} else {
				vlesti.getOtherLeakErrorInformationList().add(new ArrayList<String>());
				vlesti.getOtherLeakErrorInformationList().get(vlesti.getUniqueOtherLeakErrorCount()).add(getUniqueStackTrace("OtherLeak", pos));
				vlesti.getOtherLeakErrorInformationList().get(vlesti.getUniqueOtherLeakErrorCount()).add(getStackTraceFrequency(pos)+"");
				vlesti.getFileNamesListForOtherLeakErrorType().add(getFileNamesContainingStackTrace(pos));
				vlesti.setUniqueOtherLeakErrorCount(vlesti.getUniqueOtherLeakErrorCount() + 1);
			}
			vlesti.setUniqueTotalLeakErrorCount(vlesti.getUniqueTotalLeakErrorCount() + 1);
		}
	}

	/**
	 * Gets the leak/error stack trace at the particular index
	 * @param leakType type of leak/error stack trace
	 * @param pos index
	 * @return stackTrace leak/error stack trace at the given index
	 */
	private String getUniqueStackTrace(String leakType, int pos) {
		String stackTrace;
		if(leakType.equals("Leak_DefinitelyLost") || leakType.equals("Leak_IndirectlyLost") || leakType.equals("Leak_PossiblyLost") || leakType.equals("Leak_StillReachable")) {
			stackTrace = "Maximum Bytes Lost = " + leakedBytesList.get(pos).get(0) + "%" +
					"Sum of Bytes Lost = " + leakedBytesList.get(pos).get(1) + "%\n\n%" + uniqueLeakErrorStackTraceList.get(pos);
		} else {
			stackTrace = uniqueLeakErrorStackTraceList.get(pos);
		}
		leakedBytesList.get(pos).clear();
		leakedBytesList.remove(pos);
		uniqueLeakErrorStackTraceList.remove(pos);
		return stackTrace;
	}

	/**
	 * Gets the frequency of occurrence of leak/error stack trace at the particular index
	 * @param pos index
	 * @return stackTraceFrequency frequency of occurrence of leak/error stack trace
	 */
	private int getStackTraceFrequency(int pos) {
		int stackTraceFrequency = frequencyCountOfUniqueLeakErrorStackTraceList.get(pos);
		frequencyCountOfUniqueLeakErrorStackTraceList.remove(pos);
		return stackTraceFrequency;
	}

	/**
	 * Gets the file names in which leak/error stack trace at the particular index appeared
	 * @param pos index
	 * @return filesContainingStackTrace file names in which leak/error stack trace appeared
	 */
	private ArrayList<String> getFileNamesContainingStackTrace(int pos) {
		ArrayList<String> filesContainingStackTrace = new ArrayList<String>(filesContainingUniqueLeakErrorStackTraceList.get(pos));
		filesContainingUniqueLeakErrorStackTraceList.get(pos).clear();
		filesContainingUniqueLeakErrorStackTraceList.remove(pos);
		return filesContainingStackTrace;
	}

	/**
	 * Deletes a given file/directory recursively
	 * @param file name of file/directory to be deleted
	 * @throws IOException
	 */
	private void deleteFile(File file) throws IOException {

		if(file.isDirectory()) {
			//directory is empty, then delete it
			if(file.list().length == 0) {
				file.delete();
			} else {
				String files[] = file.list();
				for (String temp : files) {
					//construct the file structure
					File fileDelete = new File(file, temp);

					//recursive delete
					deleteFile(fileDelete);
				}

				//check the directory again, if empty then delete it
				if(file.list().length == 0) {
					file.delete();
				}
			}
		} else {
			//if file, then delete it
			file.delete();
		}
	}

	/**
	 * Main method where Valgrind Log Parser execution begins
	 * @param args string array containing command line arguments provided while executing Valgrind Log Parser
	 * @throws IOException, ParserConfigurationException, IllegalArgumentException, SAXException, FileNotFoundException
	 */
	public static void main(String args[]) throws IOException, ParserConfigurationException, IllegalArgumentException, SAXException, FileNotFoundException {

		System.out.println("\n<<** Valgrind Log Parser **>>\n");

		long sDateTime = new Date().getTime();
		System.out.println("**** Start Time : " + sDateTime + " ms");

		if(args.length != 2) {
			if(args.length < 2) {
				System.out.println("ERROR : Expected number of arguments are not specified");
			} else if(args.length > 2) {
				System.out.println("ERROR : Number of arguments specified are more than expected");
			}
			System.out.println("\nCommand : java -jar vlp.jar <argument1> <argument2>");
			System.out.println("	<argument1> : Path to directory containing valgrind logs");
			System.out.println("	<argument2> : Path to directory where valgrind report should be generated\n");
			System.exit(1);
		} else {

			ValgrindLogParserAndReportGenerator vlparg = new ValgrindLogParserAndReportGenerator();

			// inputDirectory  : Name of Directory where valgrind logs are available
			vlparg.inputDirectory = args[0];

			if(!(new File(vlparg.inputDirectory)).exists()) {
				System.out.println("Error : Input Directory " + vlparg.inputDirectory + "  does not exist.\n");
				System.exit(1);
			}

			// outputDirectory : Name of Directory where valgrind report is to be generated
			vlparg.outputDirectory = args[1];

			if(!(new File(vlparg.outputDirectory)).exists()) {
				System.out.println("Error : Output Directory " + vlparg.outputDirectory + "  does not exist.\n");
				System.exit(1);
			}

			// Read valgrind log filenames and store them in a list
			vlparg.getLogFiles();

			if(vlparg.fileNames.size() == 0) {
				System.out.println("Valgrind Logs not found ...\n");
				System.exit(1);
			} else {

				System.out.println("Parsing Valgrind Logs ...\n");

				ValgrindLogParser vlp = new ValgrindLogParser();
				HashMap<String, String> invalidValgrindXMLLogsMap = vlp.parseValgrindXMLLogs(vlparg.inputDirectory, vlparg.outputDirectory, vlparg.fileNames);

				if(!(invalidValgrindXMLLogsMap.size() == 0)) {
					ArrayList<String> logNames = new ArrayList<String>(invalidValgrindXMLLogsMap.keySet());
					for(String logName : logNames) {
						int index = vlparg.fileNames.indexOf(logName);
						vlparg.fileNames.remove(index);
						vlparg.deleteFile(new File(vlparg.outputDirectory + FILE_SEPARATOR + "Log_ParsedFiles" + FILE_SEPARATOR + logName));
						vlparg.deleteFile(new File(vlparg.outputDirectory + FILE_SEPARATOR + "Log_LeakedBytes" + FILE_SEPARATOR + logName));
						System.out.println("Warning : " + invalidValgrindXMLLogsMap.get(logName) + "\n");
					}
				}

				ValgrindLeakErrorStackTraceInformation vlesti = new ValgrindLeakErrorStackTraceInformation();

				// Prepare unique leak/error trace information
				System.out.println("Preparing unique leak\\error trace information ...");
				vlparg.prepareUniqueLeakErrorTraceInfo(vlesti);

				// Prepare contents for Valgrind Report
				System.out.println("\nPreparing Valgrind Report ...\n");
				vlparg.prepareValgrindReport(vlesti);

				ValgrindReportGenerator vrg = new ValgrindReportGenerator();

				// Print Valgrind Report
				System.out.println("Printing Valgrind Report ...\n");
				vrg.printValgrindReport(vlesti, vlparg.outputDirectory, invalidValgrindXMLLogsMap);

				System.out.println("Valgrind Report generated successfully ...\n");
			}
		}
		long eDateTime = new Date().getTime();
		System.out.println("**** End Time : " + eDateTime + " ms");
		System.out.println("\n**** Time Difference = " + (eDateTime - sDateTime) + " ms");
	}
}
